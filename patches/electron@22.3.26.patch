diff --git a/electron.d.ts b/electron.d.ts
index 1ce7930cf2fc83d15dc38d7d61058b7d8b3f48b1..6ea6c6d086b43e5100e9222dddfbc6a5e8e3fbea 100644
--- a/electron.d.ts
+++ b/electron.d.ts
@@ -1,9 +1,19 @@
-// Type definitions for Electron 22.3.26
+// Type definitions for Electron 22.3.26 (patched)
 // Project: http://electronjs.org/
 // Definitions by: The Electron Team <https://github.com/electron/electron>
 // Definitions: https://github.com/electron/electron-typescript-definitions
 
 /// <reference types="node" />
+/// <reference types="../../../../../types/globals.d.ts" />
+
+///* Section: Patch
+type $Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;
+
+type $MapKeys<T> = { [K in keyof T as EventName<K & string>]: T[K] };
+type $MappedAPI = $MapKeys<Omit<ElectronAPI, 'isBrowser'>>; // TODO: Make this more flexible so it omits any key that is not a function
+type $MappedMainAPI = $MapKeys<MainAPI>;
+type $ReturnType<T> = T | Awaited<T> | Promise<Awaited<T>>;
+///* End section
 
 type GlobalEvent = Event & { returnValue: any };
 
@@ -5173,38 +5183,59 @@ declare namespace Electron {
      * are serialized and only the `message` property from the original error is
      * provided to the renderer process. Please refer to #24427 for details.
      */
-    handle(channel: string, listener: (event: IpcMainInvokeEvent, ...args: any[]) => (Promise<void>) | (any)): void;
+    handle<K extends keyof $MappedAPI>(
+      channel: K,
+      listener: $MappedAPI[K] extends (...args: infer Args) => infer Ret
+        ? (event: IpcMainInvokeEvent, ...args: Args) => $ReturnType<NonNullable<Ret>>
+        : never,
+    ): void;
     /**
      * Handles a single `invoke`able IPC message, then removes the listener. See
      * `ipcMain.handle(channel, listener)`.
      */
-    handleOnce(channel: string, listener: (event: IpcMainInvokeEvent, ...args: any[]) => (Promise<void>) | (any)): void;
+    handleOnce<K extends keyof $MappedAPI>(
+      channel: K,
+      listener: $MappedAPI[K] extends (...args: infer Args) => infer Ret
+        ? (event: IpcMainInvokeEvent, ...args: Args) => $ReturnType<NonNullable<Ret>>
+        : never,
+    ): void;
     /**
      * Listens to `channel`, when a new message arrives `listener` would be called with
      * `listener(event, args...)`.
      */
-    on(channel: string, listener: (event: IpcMainEvent, ...args: any[]) => void): this;
+    on<K extends keyof $MappedAPI>(
+      channel: K,
+      listener: $MappedAPI[K] extends (...args: infer Args) => infer Ret
+        ? (event: IpcMainEvent<Awaited<Ret>>, ...args: Args) => void
+        : never,
+    ): this;
     /**
      * Adds a one time `listener` function for the event. This `listener` is invoked
      * only the next time a message is sent to `channel`, after which it is removed.
      */
-    once(channel: string, listener: (event: IpcMainEvent, ...args: any[]) => void): this;
+    once<K extends keyof $MappedAPI>(
+      channel: K,
+      listener: $MappedAPI[K] extends (...args: infer Args) => infer Ret
+        ? (event: IpcMainEvent<Awaited<Ret>>, ...args: Args) => void
+        : never,
+    ): this;
     /**
      * Removes listeners of the specified `channel`.
      */
-    removeAllListeners(channel?: string): this;
+    removeAllListeners(channel?: keyof $MappedAPI): this;
+
     /**
      * Removes any handler for `channel`, if present.
      */
-    removeHandler(channel: string): void;
+    removeHandler(channel: keyof $MappedAPI): void;
     /**
      * Removes the specified `listener` from the listener array for the specified
      * `channel`.
      */
-    removeListener(channel: string, listener: (...args: any[]) => void): this;
+    removeListener(channel: keyof $MappedAPI, listener: (...args: any[]) => void): this;
   }
 
-  interface IpcMainEvent extends Event {
+  interface IpcMainEvent<T = any> extends Event {
 
     // Docs: https://electronjs.org/docs/api/structures/ipc-main-event
 
@@ -5226,11 +5257,11 @@ declare namespace Electron {
      * "reply" to the sent message in order to guarantee the reply will go to the
      * correct process and frame.
      */
-    reply: Function;
+    reply<K extends keyof $MappedMainAPI>(channel: K, ...args: ForceArr<$MappedMainAPI[K]>): void;
     /**
      * Set this to the value to be returned in a synchronous message
      */
-    returnValue: any;
+    returnValue: T;
     /**
      * Returns the `webContents` that sent the message
      */
@@ -5299,18 +5330,27 @@ declare namespace Electron {
      * returned by `invoke` will reject. However, the `Error` object in the renderer
      * process will not be the same as the one thrown in the main process.
      */
-    invoke(channel: string, ...args: any[]): Promise<any>;
+    invoke<K extends keyof $MappedAPI>(channel: K, ...args: $Parameters<$MappedAPI[K]>): Promise<ReturnType<$MappedAPI[K]>>;
     /**
      * Listens to `channel`, when a new message arrives `listener` would be called with
      * `listener(event, args...)`.
      */
-    on(channel: string, listener: (event: IpcRendererEvent, ...args: any[]) => void): this;
+    on<K extends keyof $MappedMainAPI>(
+      channel: K,
+      listener: (event: IpcRendererEvent, ...args: ForceArr<$MappedMainAPI[K]>) => void,
+    ): this;
     /**
      * Adds a one time `listener` function for the event. This `listener` is invoked
      * only the next time a message is sent to `channel`, after which it is removed.
      */
-    once(channel: string, listener: (event: IpcRendererEvent, ...args: any[]) => void): this;
+    once<K extends keyof $MappedMainAPI>(
+      channel: K,
+      listener: (event: IpcRendererEvent, ...args: ForceArr<$MappedMainAPI[K]>) => void,
+    ): this;
+    // TODO: Type this properly
     /**
+     * @deprecated (patched) use is discouraged as it is not typed properly
+     * 
      * Send a message to the main process, optionally transferring ownership of zero or
      * more `MessagePort` objects.
      *
@@ -5327,12 +5367,12 @@ declare namespace Electron {
     /**
      * Removes all listeners, or those of the specified `channel`.
      */
-    removeAllListeners(channel: string): this;
+    removeAllListeners(channel?: keyof $MappedMainAPI): this;
     /**
      * Removes the specified `listener` from the listener array for the specified
      * `channel`.
      */
-    removeListener(channel: string, listener: (...args: any[]) => void): this;
+    removeListener(channel: keyof $MappedMainAPI, listener: (event: IpcRendererEvent, ...args: any[]) => void): this;
     /**
      * Send an asynchronous message to the main process via `channel`, along with
      * arguments. Arguments will be serialized with the Structured Clone Algorithm,
@@ -5357,7 +5397,7 @@ declare namespace Electron {
      * If you want to receive a single response from the main process, like the result
      * of a method call, consider using `ipcRenderer.invoke`.
      */
-    send(channel: string, ...args: any[]): void;
+    send<K extends keyof $MappedAPI>(channel: K, ...args: $Parameters<$MappedAPI[K]>): void;
     /**
      * The value sent back by the `ipcMain` handler.
      *
@@ -5382,16 +5422,16 @@ declare namespace Electron {
      * renderer process until the reply is received, so use this method only as a last
      * resort. It's much better to use the asynchronous version, `invoke()`.
      */
-    sendSync(channel: string, ...args: any[]): any;
+    sendSync<K extends keyof $MappedAPI>(channel: K, ...args: $Parameters<$MappedAPI[K]>): ReturnType<$MappedAPI[K]>;
     /**
      * Sends a message to a window with `webContentsId` via `channel`.
      */
-    sendTo(webContentsId: number, channel: string, ...args: any[]): void;
+    sendTo<K extends keyof $MappedAPI>(webContentsId: number, channel: K, ...args: $Parameters<$MappedAPI[K]>): void;
     /**
      * Like `ipcRenderer.send` but the event will be sent to the `<webview>` element in
      * the host page instead of the main process.
      */
-    sendToHost(channel: string, ...args: any[]): void;
+    sendToHost<K extends keyof $MappedAPI>(channel: K, ...args: $Parameters<$MappedAPI[K]>): void;
   }
 
   interface IpcRendererEvent extends Event {
@@ -11663,7 +11703,7 @@ declare namespace Electron {
      *
      * An example of sending messages from the main process to the renderer process:
      */
-    send(channel: string, ...args: any[]): void;
+    send<K extends keyof $MappedMainAPI>(channel: K, ...args: ForceArr<$MappedMainAPI[K]>): void;
     /**
      * Sends an input `event` to the page. **Note:** The `BrowserWindow` containing the
      * contents needs to be focused for `sendInputEvent()` to work.
@@ -11931,6 +11971,22 @@ declare namespace Electron {
      * respectively. The formula for this is `scale := 1.2 ^ level`.
      */
     zoomLevel: number;
+    /**
+     * @patched - this was added by popcorn
+     * An object containing info about the original preload
+     */
+    originalWindowData?: {
+      originalPreload: string;
+      windowOptions: Electron.BrowserWindowConstructorOptions;
+    };
+    /**
+     * @patched - this was added by kernel
+     * An object containing info about the original preload
+     */
+    kernelWindowData?: {
+      originalPreload: string;
+      windowOptions: Electron.BrowserWindowConstructorOptions;
+    };
   }

   interface WebFrame extends NodeJS.EventEmitter {
@@ -12179,7 +12235,7 @@ declare namespace Electron {
      * The renderer process can handle the message by listening to `channel` with the
      * `ipcRenderer` module.
      */
-    send(channel: string, ...args: any[]): void;
+    send<K extends keyof $MappedMainAPI>(channel: K, ...args: ForceArr<$MappedMainAPI[K]>): void;
     /**
      * A `WebFrameMain[]` collection containing the direct descendents of `frame`.
      *
@@ -18119,34 +18175,34 @@ declare namespace Electron {

 }

-declare module 'electron' {
+declare module 'electron-legacy' {
   export = Electron.CrossProcessExports;
 }

-declare module 'electron/main' {
+declare module 'electron-legacy/main' {
   export = Electron.Main
 }

-declare module 'electron/common' {
+declare module 'electron-legacy/common' {
   export = Electron.Common
 }

-declare module 'electron/renderer' {
+declare module 'electron-legacy/renderer' {
   export = Electron.Renderer
 }

 interface NodeRequireFunction {
-  (moduleName: 'electron'): typeof Electron.CrossProcessExports;
-  (moduleName: 'electron/main'): typeof Electron.Main;
-  (moduleName: 'electron/common'): typeof Electron.Common;
-  (moduleName: 'electron/renderer'): typeof Electron.Renderer;
+  (moduleName: 'electron-legacy'): typeof Electron.CrossProcessExports;
+  (moduleName: 'electron-legacy/main'): typeof Electron.Main;
+  (moduleName: 'electron-legacy/common'): typeof Electron.Common;
+  (moduleName: 'electron-legacy/renderer'): typeof Electron.Renderer;
 }

 interface NodeRequire {
-  (moduleName: 'electron'): typeof Electron.CrossProcessExports;
-  (moduleName: 'electron/main'): typeof Electron.Main;
-  (moduleName: 'electron/common'): typeof Electron.Common;
-  (moduleName: 'electron/renderer'): typeof Electron.Renderer;
+  (moduleName: 'electron-legacy'): typeof Electron.CrossProcessExports;
+  (moduleName: 'electron-legacy/main'): typeof Electron.Main;
+  (moduleName: 'electron-legacy/common'): typeof Electron.Common;
+  (moduleName: 'electron-legacy/renderer'): typeof Electron.Renderer;
 }

 interface File {
